"""
üß™ Testes Reais End-to-End - Jornadas Completas do Usu√°rio
Testa fluxos completos reais sem mocks, do in√≠cio ao fim
"""
import pytest
import asyncio
import time
from datetime import datetime, timedelta


class TestRealUserJourneys:
    """üéØ Jornadas reais completas de usu√°rios"""
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    @pytest.mark.conversation
    async def test_complete_discovery_journey(self, conversation_tester, real_test_reporter):
        """Testa jornada completa de descoberta dos servi√ßos"""
        start_time = time.time()
        
        # Jornada real de um cliente descobrindo os servi√ßos
        discovery_flow = [
            "Oi!",
            "Voc√™s fazem corte de cabelo?",
            "Que tipos de corte voc√™s fazem?",
            "Quanto custa?",
            "E barba? Fazem tamb√©m?",
            "Qual o pre√ßo da barba?",
            "Tem algum pacote corte + barba?",
            "Que hor√°rio voc√™s funcionam?",
            "Trabalham no s√°bado?",
            "Domingo tamb√©m?",
            "Onde fica a barbearia?",
            "√â f√°cil de chegar?",
            "Tem estacionamento?",
            "Como √© o pagamento? Aceitam cart√£o?",
            "PIX tamb√©m?",
            "Perfeito! Obrigado pelas informa√ß√µes"
        ]
        
        print(f"\nüîç INICIANDO JORNADA DE DESCOBERTA")
        print(f"üì± Telefone: {conversation_tester.phone}")
        print(f"üí¨ Mensagens a enviar: {len(discovery_flow)}")
        
        results = await conversation_tester.send_conversation_flow(
            discovery_flow,
            delay=2.0  # 2 segundos entre mensagens para simular real
        )
        
        duration = time.time() - start_time
        success_rate = conversation_tester.get_success_rate()
        
        real_test_reporter.record_test(
            "complete_discovery_journey",
            success_rate >= 85.0,
            duration,
            {
                "journey_type": "discovery",
                "total_messages": len(discovery_flow),
                "success_rate": success_rate,
                "duration": duration,
                "phone": conversation_tester.phone
            }
        )
        
        assert success_rate >= 85.0, f"Jornada de descoberta falhou: {success_rate:.1f}%"
        
        print(f"‚úÖ JORNADA DE DESCOBERTA COMPLETA")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration:.1f}s")
        print(f"üìà Taxa de sucesso: {success_rate:.1f}%")
        print(f"üí¨ Mensagens processadas: {len(results)}")
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    @pytest.mark.conversation
    async def test_complete_booking_journey(self, conversation_tester, real_test_reporter):
        """Testa jornada completa de agendamento real"""
        start_time = time.time()
        
        customer_name = f"Cliente Teste {int(time.time())}"
        
        # Jornada completa de agendamento
        booking_flow = [
            "Ol√°, boa tarde!",
            "Gostaria de agendar um corte de cabelo",
            "Para amanh√£, se poss√≠vel",
            "Que hor√°rios voc√™s t√™m dispon√≠vel?",
            "Manh√£ ou tarde?",
            "Prefiro de tarde",
            "14h est√° bom?",
            "15h tamb√©m serve",
            "Ent√£o vamos de 15h mesmo",
            f"Meu nome √© {customer_name}",
            "√â Jo√£o mesmo",
            "Telefone √© esse mesmo que estou falando",
            "Quero s√≥ o corte masculino",
            "Quanto fica?",
            "Perfeito",
            "Confirmo o agendamento",
            "Para amanh√£ √†s 15h",
            "Muito obrigado!",
            "At√© amanh√£"
        ]
        
        print(f"\nüìÖ INICIANDO JORNADA DE AGENDAMENTO")
        print(f"üì± Telefone: {conversation_tester.phone}")
        print(f"üë§ Cliente: {customer_name}")
        print(f"üí¨ Mensagens a enviar: {len(booking_flow)}")
        
        results = await conversation_tester.send_conversation_flow(
            booking_flow,
            delay=2.5  # 2.5 segundos entre mensagens
        )
        
        duration = time.time() - start_time
        success_rate = conversation_tester.get_success_rate()
        
        real_test_reporter.record_test(
            "complete_booking_journey",
            success_rate >= 85.0,
            duration,
            {
                "journey_type": "booking",
                "customer_name": customer_name,
                "total_messages": len(booking_flow),
                "success_rate": success_rate,
                "duration": duration,
                "phone": conversation_tester.phone
            }
        )
        
        assert success_rate >= 85.0, f"Jornada de agendamento falhou: {success_rate:.1f}%"
        
        print(f"‚úÖ JORNADA DE AGENDAMENTO COMPLETA")
        print(f"üë§ Cliente: {customer_name}")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration:.1f}s")
        print(f"üìà Taxa de sucesso: {success_rate:.1f}%")
        print(f"üí¨ Mensagens processadas: {len(results)}")
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    @pytest.mark.conversation
    async def test_complete_support_journey(self, conversation_tester, real_test_reporter):
        """Testa jornada completa de suporte/d√∫vidas"""
        start_time = time.time()
        
        # Jornada de suporte com m√∫ltiplas d√∫vidas
        support_flow = [
            "Oi, preciso de ajuda",
            "Marquei um hor√°rio mas esqueci quando √©",
            "√â para hoje?",
            "Ou √© amanh√£?",
            "Foi marcado em nome de Jo√£o Silva",
            "Pode verificar pra mim?",
            "Ah, e onde fica a barbearia mesmo?",
            "√â perto do shopping?",
            "Tem ponto de refer√™ncia?",
            "Como chego de √¥nibus?",
            "E de carro?",
            "Que horas voc√™s abrem?",
            "E fecham que horas?",
            "Almo√ßam que horas?",
            "Preciso chegar antes do almo√ßo",
            "Posso remarcar se precisar?",
            "At√© que horas posso cancelar?",
            "Tem taxa de cancelamento?",
            "Entendi, obrigado",
            "At√© logo!"
        ]
        
        print(f"\nüÜò INICIANDO JORNADA DE SUPORTE")
        print(f"üì± Telefone: {conversation_tester.phone}")
        print(f"üí¨ Mensagens a enviar: {len(support_flow)}")
        
        results = await conversation_tester.send_conversation_flow(
            support_flow,
            delay=1.8  # 1.8 segundos entre mensagens
        )
        
        duration = time.time() - start_time
        success_rate = conversation_tester.get_success_rate()
        
        real_test_reporter.record_test(
            "complete_support_journey",
            success_rate >= 85.0,
            duration,
            {
                "journey_type": "support",
                "total_messages": len(support_flow),
                "success_rate": success_rate,
                "duration": duration,
                "phone": conversation_tester.phone
            }
        )
        
        assert success_rate >= 85.0, f"Jornada de suporte falhou: {success_rate:.1f}%"
        
        print(f"‚úÖ JORNADA DE SUPORTE COMPLETA")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration:.1f}s")
        print(f"üìà Taxa de sucesso: {success_rate:.1f}%")
        print(f"üí¨ Mensagens processadas: {len(results)}")


class TestRealComplexScenarios:
    """üé≠ Cen√°rios reais complexos e realistas"""
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    @pytest.mark.slow
    async def test_indecisive_customer_journey(self, conversation_tester, real_test_reporter):
        """Testa cliente indeciso que muda de ideia v√°rias vezes"""
        start_time = time.time()
        
        # Cliente indeciso e realista
        indecisive_flow = [
            "Oi",
            "Quero cortar o cabelo",
            "Na verdade, n√£o sei se quero",
            "Quanto custa mesmo?",
            "Hmmm, est√° caro",
            "Tem desconto?",
            "E se eu trouxer um amigo?",
            "Na verdade, quero s√≥ a barba",
            "N√£o, melhor s√≥ corte mesmo",
            "Ou o pacote completo",
            "Deixa eu pensar...",
            "Voc√™s fazem sobrancelha tamb√©m?",
            "Ah, que bom",
            "Ent√£o quero corte + sobrancelha",
            "Para quando posso agendar?",
            "Amanh√£ √© muito em cima?",
            "E depois de amanh√£?",
            "Que hor√°rios t√™m?",
            "De manh√£ eu n√£o posso",
            "Tarde tamb√©m √© complicado",
            "Noite voc√™s atendem?",
            "Ah, n√£o atendem...",
            "Ent√£o tem que ser tarde mesmo",
            "15h30 pode ser?",
            "Ou 16h?",
            "Melhor 16h",
            "Meu nome √© Carlos",
            "Carlos da Silva",
            "Pode confirmar?",
            "Espera, mudei de ideia",
            "Quero s√≥ o corte mesmo",
            "Confirma s√≥ o corte?",
            "Para 16h de depois de amanh√£",
            "Isso mesmo",
            "Valeu!"
        ]
        
        print(f"\nü§î INICIANDO JORNADA CLIENTE INDECISO")
        print(f"üì± Telefone: {conversation_tester.phone}")
        print(f"üí¨ Mensagens a enviar: {len(indecisive_flow)}")
        
        results = await conversation_tester.send_conversation_flow(
            indecisive_flow,
            delay=1.5  # Cliente indeciso demora entre mensagens
        )
        
        duration = time.time() - start_time
        success_rate = conversation_tester.get_success_rate()
        
        real_test_reporter.record_test(
            "indecisive_customer_journey",
            success_rate >= 80.0,  # Mais flex√≠vel para cen√°rio complexo
            duration,
            {
                "journey_type": "indecisive_customer",
                "total_messages": len(indecisive_flow),
                "success_rate": success_rate,
                "duration": duration,
                "complexity": "high"
            }
        )
        
        assert success_rate >= 80.0, f"Cliente indeciso falhou: {success_rate:.1f}%"
        
        print(f"‚úÖ JORNADA CLIENTE INDECISO COMPLETA")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration:.1f}s")
        print(f"üìà Taxa de sucesso: {success_rate:.1f}%")
        print(f"ü§î Mudan√ßas de ideia processadas: {len(results)}")
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    async def test_upset_customer_recovery(self, conversation_tester, real_test_reporter):
        """Testa recupera√ß√£o de cliente insatisfeito"""
        start_time = time.time()
        
        # Cliente come√ßando insatisfeito
        upset_recovery_flow = [
            "Olha, estou muito chateado",
            "Marquei hor√°rio ontem e ningu√©m me atendeu",
            "Cheguei na hora certa",
            "Esperei 30 minutos",
            "E nada",
            "Isso √© falta de respeito",
            "Quero uma explica√ß√£o",
            "N√£o √© a primeira vez que isso acontece",
            "Estou pensando em procurar outra barbearia",
            "Voc√™s podem me dar uma satisfa√ß√£o?",
            "Pelo menos uma desculpa?",
            "Ok, aceito a explica√ß√£o",
            "Mas quero garantia que n√£o vai acontecer de novo",
            "Posso remarcar?",
            "Para amanh√£ mesmo",
            "Que horas voc√™s garantem que v√£o me atender?",
            "14h est√° bom",
            "Meu nome √© Roberto Santos",
            "Espero n√£o ter problemas dessa vez",
            "Confirma a√≠ pra mim",
            "E me mandem uma mensagem pra confirmar",
            "Valeu, at√© amanh√£",
            "Confio que vai dar certo dessa vez"
        ]
        
        print(f"\nüò† INICIANDO JORNADA CLIENTE INSATISFEITO")
        print(f"üì± Telefone: {conversation_tester.phone}")
        print(f"üí¨ Mensagens a enviar: {len(upset_recovery_flow)}")
        
        results = await conversation_tester.send_conversation_flow(
            upset_recovery_flow,
            delay=2.2  # Cliente chateado demora mais para escrever
        )
        
        duration = time.time() - start_time
        success_rate = conversation_tester.get_success_rate()
        
        real_test_reporter.record_test(
            "upset_customer_recovery",
            success_rate >= 80.0,
            duration,
            {
                "journey_type": "upset_customer_recovery",
                "total_messages": len(upset_recovery_flow),
                "success_rate": success_rate,
                "duration": duration,
                "emotional_context": "upset_to_satisfied"
            }
        )
        
        assert success_rate >= 80.0, f"Recupera√ß√£o de cliente falhou: {success_rate:.1f}%"
        
        print(f"‚úÖ RECUPERA√á√ÉO DE CLIENTE COMPLETA")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration:.1f}s")
        print(f"üìà Taxa de sucesso: {success_rate:.1f}%")
        print(f"üîÑ Cliente recuperado com sucesso")


class TestRealMultiUserScenarios:
    """üë• Testes reais com m√∫ltiplos usu√°rios simult√¢neos"""
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    @pytest.mark.performance
    async def test_concurrent_real_conversations(self, real_api_client, real_test_reporter):
        """Testa conversas reais simult√¢neas"""
        start_time = time.time()
        
        # Diferentes tipos de clientes simult√¢neos
        customer_scenarios = [
            {
                "phone": f"5511800{int(time.time() % 100000):05d}",
                "type": "quick_booker",
                "messages": [
                    "Oi, quero agendar",
                    "Para hoje √† tarde",
                    "16h pode?",
                    "Jo√£o Silva",
                    "Confirma"
                ]
            },
            {
                "phone": f"5511801{int(time.time() % 100000):05d}",
                "type": "price_shopper",
                "messages": [
                    "Quanto custa corte?",
                    "E barba?",
                    "Tem desconto?",
                    "Obrigado"
                ]
            },
            {
                "phone": f"5511802{int(time.time() % 100000):05d}",
                "type": "detailed_inquirer",
                "messages": [
                    "Oi, tenho algumas d√∫vidas",
                    "Que tipos de corte fazem?",
                    "Trabalham com m√°quina ou tesoura?",
                    "Fazem degrad√™?",
                    "E corte social?",
                    "Quanto custa cada um?",
                    "Onde fica?",
                    "Valeu!"
                ]
            }
        ]
        
        async def execute_customer_scenario(scenario):
            """Executa cen√°rio de um cliente"""
            results = []
            for message in scenario["messages"]:
                result = await real_api_client.send_webhook_message(
                    scenario["phone"], 
                    message
                )
                results.append(result)
                await asyncio.sleep(1.0)  # 1 segundo entre mensagens do mesmo cliente
            
            success_rate = (sum(1 for r in results if r["success"]) / len(results)) * 100
            return {
                "phone": scenario["phone"],
                "type": scenario["type"],
                "success_rate": success_rate,
                "total_messages": len(results)
            }
        
        print(f"\nüë• INICIANDO CONVERSAS SIMULT√ÇNEAS")
        print(f"üé≠ Cen√°rios: {len(customer_scenarios)}")
        
        # Executar todos os cen√°rios simultaneamente
        tasks = [execute_customer_scenario(scenario) for scenario in customer_scenarios]
        scenario_results = await asyncio.gather(*tasks)
        
        duration = time.time() - start_time
        
        # Calcular m√©tricas gerais
        total_messages = sum(r["total_messages"] for r in scenario_results)
        avg_success_rate = sum(r["success_rate"] for r in scenario_results) / len(scenario_results)
        
        real_test_reporter.record_test(
            "concurrent_real_conversations",
            avg_success_rate >= 80.0,
            duration,
            {
                "total_scenarios": len(customer_scenarios),
                "total_messages": total_messages,
                "average_success_rate": avg_success_rate,
                "scenario_results": scenario_results
            }
        )
        
        assert avg_success_rate >= 80.0, f"Conversas simult√¢neas falharam: {avg_success_rate:.1f}%"
        
        print(f"‚úÖ CONVERSAS SIMULT√ÇNEAS COMPLETAS")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration:.1f}s")
        print(f"üìä Total de mensagens: {total_messages}")
        print(f"üìà Taxa m√©dia de sucesso: {avg_success_rate:.1f}%")
        
        for result in scenario_results:
            print(f"  üì± {result['type']}: {result['success_rate']:.1f}% ({result['total_messages']} msgs)")


class TestRealSystemLimits:
    """üî¨ Testes reais dos limites do sistema"""
    
    @pytest.mark.real
    @pytest.mark.e2e_real
    @pytest.mark.slow
    async def test_very_long_conversation(self, conversation_tester, real_test_reporter):
        """Testa conversa muito longa e detalhada"""
        start_time = time.time()
        
        # Conversa extremamente longa simulando cliente muito detalhista
        very_long_conversation = [
            "Ol√°, boa tarde",
            "Estou procurando uma barbearia boa na regi√£o",
            "Vi que voc√™s t√™m boas avalia√ß√µes",
            "Gostaria de saber mais sobre os servi√ßos",
            "Fazem corte masculino?",
            "Que tipos de corte voc√™s fazem?",
            "Fazem corte social?",
            "E degrad√™?",
            "Corte com m√°quina tamb√©m?",
            "S√≥ tesoura?",
            "Como √© o processo?",
            "Lavam o cabelo antes?",
            "E depois?",
            "Usam produtos especiais?",
            "Fazem barba tamb√©m?",
            "Como √© feita a barba?",
            "Usam navalha?",
            "Ou s√≥ m√°quina?",
            "Fazem bigode?",
            "E costeleta?",
            "Sobrancelha masculina fazem?",
            "Como √© o procedimento?",
            "D√≥i muito?",
            "Quanto tempo demora cada servi√ßo?",
            "Corte demora quanto tempo?",
            "E barba?",
            "Sobrancelha?",
            "Se eu fizer tudo junto, quanto tempo fica?",
            "E o pre√ßo de cada um?",
            "Corte custa quanto?",
            "Barba?",
            "Sobrancelha?",
            "Tem algum pacote?",
            "Desconto para tudo junto?",
            "Como funciona o agendamento?",
            "Posso escolher o hor√°rio?",
            "E o profissional?",
            "Tem prefer√™ncia?",
            "Como √© o local?",
            "√â limpo?",
            "Esterilizam os equipamentos?",
            "Seguem protocolos de higiene?",
            "Onde fica exatamente?",
            "√â f√°cil de achar?",
            "Tem ponto de refer√™ncia?",
            "Como chego de transporte p√∫blico?",
            "Tem estacionamento?",
            "√â pago?",
            "Que horas abrem?",
            "E fecham?",
            "Funcionam aos s√°bados?",
            "E domingos?",
            "Feriados atendem?",
            "Como √© o pagamento?",
            "Aceitam dinheiro?",
            "Cart√£o de d√©bito?",
            "Cr√©dito?",
            "PIX?",
            "Pode pagar na hora?",
            "Ou tem que pagar antes?",
            "Se eu quiser remarcar, posso?",
            "At√© quando posso cancelar?",
            "Tem taxa de cancelamento?",
            "E se eu me atrasar?",
            "Quanto tempo esperam?",
            "Posso levar acompanhante?",
            "Tem lugar para esperar?",
            "Oferecem alguma coisa? Caf√©, √°gua?",
            "Ok, acho que esclareceu tudo",
            "Quero agendar ent√£o",
            "Para quando posso?",
            "Amanh√£ tem vaga?",
            "Que horas?",
            "De manh√£ prefiro",
            "9h pode ser?",
            "Ou 10h?",
            "10h est√° bom",
            "Quero o pacote completo",
            "Corte + barba + sobrancelha",
            "Quanto fica tudo?",
            "Perfeito",
            "Meu nome √© Fernando Silva",
            "Telefone √© este mesmo",
            "Endere√ßo precisa?",
            "Moro na Vila Madalena",
            "Confirma para mim?",
            "Amanh√£ √†s 10h",
            "Pacote completo",
            "Quanto tempo vai demorar tudo?",
            "Ok, chegou 10 minutos antes",
            "Perfeito",
            "Muito obrigado",
            "At√© amanh√£!"
        ]
        
        print(f"\nüìö INICIANDO CONVERSA MUITO LONGA")
        print(f"üì± Telefone: {conversation_tester.phone}")
        print(f"üí¨ Mensagens a enviar: {len(very_long_conversation)}")
        print(f"‚è±Ô∏è Tempo estimado: ~{len(very_long_conversation) * 1.5 / 60:.1f} minutos")
        
        results = await conversation_tester.send_conversation_flow(
            very_long_conversation,
            delay=1.5  # 1.5 segundos entre mensagens
        )
        
        duration = time.time() - start_time
        success_rate = conversation_tester.get_success_rate()
        
        real_test_reporter.record_test(
            "very_long_conversation",
            success_rate >= 80.0,
            duration,
            {
                "journey_type": "very_long_detailed",
                "total_messages": len(very_long_conversation),
                "success_rate": success_rate,
                "duration": duration,
                "conversation_length": "extreme"
            }
        )
        
        assert success_rate >= 80.0, f"Conversa longa falhou: {success_rate:.1f}%"
        
        print(f"‚úÖ CONVERSA MUITO LONGA COMPLETA")
        print(f"‚è±Ô∏è Dura√ß√£o: {duration/60:.1f} minutos")
        print(f"üìà Taxa de sucesso: {success_rate:.1f}%")
        print(f"üí¨ Total de mensagens: {len(results)}")
        print(f"üèÜ Sistema suportou conversa extremamente detalhada!")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short", "-m", "real and e2e_real"])
