"""
Servi√ßo de Dados de Neg√≥cio - Interface com Database
Busca informa√ß√µes reais da database ao inv√©s de usar dados hardcoded
"""

from typing import List, Dict, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, text
from app.models.database import Service, Business, CompanyInfo
from app.utils.logger import get_logger
from app.database import AsyncSessionLocal
logger = get_logger(__name__)
import logging

logger = logging.getLogger(__name__)


class ServiceData:
    """Classe simples para representar dados de servi√ßo"""
    def __init__(self, id: int, name: str, price: str, duration: int, description: str = ""):
        self.id = id
        self.name = name
        self.price = price  # Agora √© string (ex: "R$ 50,00")
        self.duration = duration
        self.description = description
    
    def __repr__(self):
        return f"ServiceData(name='{self.name}', price='{self.price}', duration={self.duration})"


class BusinessDataService:
    """Servi√ßo para buscar dados reais do neg√≥cio da database"""
    
    def __init__(self, business_id: int = 1):
        self.business_id = business_id
        self._services_cache = None
        self._company_info_cache = None
        self._business_hours_cache = None
        self._payment_methods_cache = None
        self._policies_cache = None
    
    async def get_active_services(self, refresh_cache: bool = False) -> List[ServiceData]:
        """
        Busca servi√ßos ativos da database
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista de objetos ServiceData com nome, pre√ßo e dura√ß√£o
        """
        if self._services_cache is None or refresh_cache:
            async with AsyncSessionLocal() as db:
                try:
                    result = await db.execute(
                        select(Service).where(
                            and_(
                                Service.business_id == self.business_id,
                                Service.is_active == True
                            )
                        ).order_by(Service.name)
                    )
                    services = result.scalars().all()
                    
                    self._services_cache = [
                        ServiceData(
                            id=service.id,
                            name=service.name,
                            price=service.price,
                            duration=service.duration_minutes,
                            description=service.description or ""
                        )
                        for service in services
                    ]
                    
                    logger.info(f"‚úÖ Carregados {len(self._services_cache)} servi√ßos da database")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro ao buscar servi√ßos: {e}")
                    self._services_cache = []
        
        return self._services_cache or []
    
    async def get_company_info(self, refresh_cache: bool = False) -> Optional[Dict]:
        """
        Busca informa√ß√µes da empresa da database
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Dicion√°rio com informa√ß√µes da empresa
        """
        if self._company_info_cache is None or refresh_cache:
            async with AsyncSessionLocal() as db:
                try:
                    result = await db.execute(
                        select(CompanyInfo).where(
                            CompanyInfo.business_id == self.business_id
                        )
                    )
                    company_info = result.scalar_one_or_none()
                    
                    if company_info:
                        self._company_info_cache = {
                            "company_name": company_info.company_name,
                            "slogan": company_info.slogan,
                            "about_us": company_info.about_us,
                            "address": getattr(company_info, 'address', ''),
                            "phone": getattr(company_info, 'phone', ''),
                            "opening_hours": getattr(company_info, 'opening_hours', {})
                        }
                    else:
                        # Fallback se n√£o houver dados
                        self._company_info_cache = {
                            "company_name": "Nossa Empresa",
                            "slogan": "Excel√™ncia em atendimento",
                            "about_us": "Oferecemos os melhores servi√ßos para voc√™!",
                            "address": "",
                            "phone": "",
                            "opening_hours": {}
                        }
                    
                    logger.info("‚úÖ Informa√ß√µes da empresa carregadas da database")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro ao buscar informa√ß√µes da empresa: {e}")
                    self._company_info_cache = None
        
        return self._company_info_cache
    
    async def get_services_formatted_text(self) -> str:
        """
        Retorna texto formatado com servi√ßos e pre√ßos da database
        Formata√ß√£o otimizada para WhatsApp com quebras de linha adequadas
        
        Returns:
            String formatada com lista de servi√ßos
        """
        services = await self.get_active_services()
        
        if not services:
            return "üîç No momento n√£o temos servi√ßos cadastrados.\nüìû Entre em contato conosco!"
        
        text = "üìã *Nossos Servi√ßos e Pre√ßos:*\n\n"
        
        for i, service in enumerate(services, 1):
            # Formata√ß√£o WhatsApp-friendly com numera√ß√£o clara
            text += f"{i}. *{service.name}*\n"
            text += f"   üí∞ {service.price}"
            if service.duration:
                text += f" ‚Ä¢ ‚è∞ {service.duration}min"
            text += "\n"
            if service.description:
                text += f"   ‚ÑπÔ∏è _{service.description}_\n"
            text += "\n"  # Linha extra entre servi√ßos para melhor separa√ß√£o
        
        text += "üìû *Para agendar:*\n"
        text += "‚Ä¢ Qual servi√ßo deseja\n"
        text += "‚Ä¢ Data e hor√°rio preferido\n"
        text += "‚Ä¢ Seu nome completo"
        
        return text
    
    async def get_company_info_formatted_text(self) -> str:
        """
        Retorna informa√ß√µes da empresa formatadas para WhatsApp
        
        Returns:
            String formatada com informa√ß√µes da empresa
        """
        company_info = await self.get_company_info()
        
        if not company_info:
            return "üè¢ *Studio Beleza & Bem-Estar*\nüìç Rua das Flores, 123 - Centro, S√£o Paulo, SP\nüìû Entre em contato conosco!"
        
        text = f"üè¢ *{company_info.get('name', 'Studio Beleza & Bem-Estar')}*\n\n"
        
        if company_info.get('address'):
            text += f"üìç *Endere√ßo:*\n{company_info['address']}\n\n"
        
        if company_info.get('phone'):
            text += f"üìû *Telefone:* {company_info['phone']}\n"
        
        if company_info.get('email'):
            text += f"üìß *E-mail:* {company_info['email']}\n"
        
        if company_info.get('website'):
            text += f"üåê *Site:* {company_info['website']}\n"
        
        # Adicionar hor√°rio de funcionamento
        text += "\n"
        hours_text = await self.get_business_hours_formatted_text()
        text += hours_text
        
        return text.strip()
    
    async def find_service_by_name(self, service_name: str) -> Optional[ServiceData]:
        """
        Busca um servi√ßo espec√≠fico pelo nome
        
        Args:
            service_name: Nome do servi√ßo para buscar
            
        Returns:
            Objeto ServiceData ou None se n√£o encontrado
        """
        services = await self.get_active_services()
        
        service_name_lower = service_name.lower()
        
        # Busca exata primeiro
        for service in services:
            if service.name.lower() == service_name_lower:
                return service
        
        # Busca parcial
        for service in services:
            if service_name_lower in service.name.lower():
                return service
        
        # Busca por palavras-chave
        keywords_map = {
            'corte masculino': ['corte', 'masculino', 'homem', 'cabelo masculino'],
            'corte feminino': ['corte', 'feminino', 'mulher', 'cabelo feminino'],
            'barba': ['barba', 'fazer barba', 'aparar barba'],
            'manicure': ['manicure', 'unha', 'fazer unha']
        }
        
        for service in services:
            service_keywords = keywords_map.get(service.name.lower(), [])
            if any(keyword in service_name_lower for keyword in service_keywords):
                return service
        
        return None
    
    async def get_business_hours(self, refresh_cache: bool = False) -> Optional[Dict]:
        """
        Busca hor√°rios de funcionamento da database
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Dicion√°rio com hor√°rios por dia da semana
        """
        if self._business_hours_cache is None or refresh_cache:
            async with AsyncSessionLocal() as db:
                try:
                    result = await db.execute(
                        text("""
                        SELECT day_of_week, is_open, open_time, close_time, notes
                        FROM business_hours 
                        WHERE business_id = :business_id
                        ORDER BY day_of_week
                        """),
                        {"business_id": self.business_id}
                    )
                    hours_data = result.fetchall()
                    
                    if hours_data:
                        days_map = {
                            0: 'Domingo', 1: 'Segunda', 2: 'Ter√ßa', 
                            3: 'Quarta', 4: 'Quinta', 5: 'Sexta', 6: 'S√°bado'
                        }
                        
                        hours_dict = {}
                        hours_text = []
                        
                        for row in hours_data:
                            day_name = days_map.get(row[0], f"Dia {row[0]}")
                            if row[1]:  # is_open
                                hours_dict[day_name] = {
                                    "open": str(row[2]),
                                    "close": str(row[3]),
                                    "is_open": True
                                }
                                hours_text.append(f"{day_name}: {row[2]} √†s {row[3]}")
                            else:
                                hours_dict[day_name] = {"is_open": False}
                                hours_text.append(f"{day_name}: Fechado")
                        
                        self._business_hours_cache = {
                            "hours_by_day": hours_dict,
                            "formatted_text": "\n".join(hours_text),
                            "summary": "Segunda a Sexta: 9h √†s 18h, S√°bado: 9h √†s 16h, Domingo: Fechado"
                        }
                    else:
                        # Retornar dados padr√£o se n√£o h√° registros
                        self._business_hours_cache = self._get_default_business_hours()
                    
                    logger.info("‚úÖ Hor√°rios de funcionamento carregados da database")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro ao buscar hor√°rios: {e}")
                    # Se a tabela n√£o existe, retornar dados padr√£o
                    if "does not exist" in str(e):
                        logger.warning("‚ö†Ô∏è  Tabela business_hours n√£o existe, usando dados padr√£o")
                        self._business_hours_cache = self._get_default_business_hours()
                    else:
                        self._business_hours_cache = None

        return self._business_hours_cache
    
    def _get_default_business_hours(self) -> Dict:
        """Retorna hor√°rios padr√£o quando a tabela n√£o existe"""
        return {
            "hours_by_day": {
                "Segunda": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Ter√ßa": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Quarta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Quinta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Sexta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "S√°bado": {"is_open": False},
                "Domingo": {"is_open": False}
            },
            "formatted_text": "Segunda a Sexta: 09:00 √†s 18:00\nS√°bado: Fechado\nDomingo: Fechado",
            "summary": "Segunda a Sexta: 9h √†s 18h, Fins de semana: Fechado"
        }
    
    async def get_business_hours_formatted_text(self) -> str:
        """
        Retorna hor√°rios de funcionamento formatados para WhatsApp
        
        Returns:
            String formatada com hor√°rios de funcionamento
        """
        hours_data = await self.get_business_hours()
        
        if not hours_data:
            return "üìÖ *Hor√°rio de Funcionamento:*\n\nüïò Segunda a Sexta: 9h √†s 18h\nüïò S√°bado: 9h √†s 16h\nüö´ Domingo: Fechado"
        
        # Usar o texto formatado do cache se dispon√≠vel
        if "formatted_text" in hours_data and hours_data["formatted_text"]:
            text = "üìÖ *Hor√°rio de Funcionamento:*\n\n"
            
            # Quebrar por linhas e reformatar
            lines = hours_data["formatted_text"].split('\n')
            for line in lines:
                if "Fechado" in line:
                    text += f"üö´ {line}\n"
                else:
                    text += f"üïò {line}\n"
            
            return text.strip()
        
        # Fallback para formato padr√£o
        return "üìÖ *Hor√°rio de Funcionamento:*\n\nüïò Segunda a Sexta: 9h √†s 18h\nüïò S√°bado: 9h √†s 16h\nüö´ Domingo: Fechado"
        
        return self._business_hours_cache
    
    async def get_payment_methods(self, refresh_cache: bool = False) -> Optional[List[Dict]]:
        """
        Busca formas de pagamento da database
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista com formas de pagamento
        """
        if self._payment_methods_cache is None or refresh_cache:
            async with AsyncSessionLocal() as db:
                try:
                    result = await db.execute(
                        text("""
                        SELECT name, description, additional_info
                        FROM payment_methods 
                        WHERE business_id = :business_id AND is_active = true
                        ORDER BY display_order
                        """),
                        {"business_id": self.business_id}
                    )
                    payment_data = result.fetchall()
                    
                    if payment_data:
                        self._payment_methods_cache = [
                            {
                                "name": row[0],
                                "description": row[1],
                                "additional_info": row[2]
                            }
                            for row in payment_data
                        ]
                    else:
                        self._payment_methods_cache = []
                    
                    logger.info(f"‚úÖ {len(self._payment_methods_cache)} formas de pagamento carregadas")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro ao buscar formas de pagamento: {e}")
                    # Se a tabela n√£o existe, usar dados padr√£o
                    if "does not exist" in str(e):
                        logger.warning("‚ö†Ô∏è  Tabela payment_methods n√£o existe, usando dados padr√£o")
                        self._payment_methods_cache = self._get_default_payment_methods()
                    else:
                        self._payment_methods_cache = []
        
        return self._payment_methods_cache
    
    async def get_business_policies(self, refresh_cache: bool = False) -> Optional[List[Dict]]:
        """
        Busca pol√≠ticas do neg√≥cio da database
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista com pol√≠ticas do neg√≥cio
        """
        if self._policies_cache is None or refresh_cache:
            async with AsyncSessionLocal() as db:
                try:
                    result = await db.execute(
                        text("""
                        SELECT policy_type, title, description, rules
                        FROM business_policies 
                        WHERE business_id = :business_id AND is_active = true
                        ORDER BY policy_type
                        """),
                        {"business_id": self.business_id}
                    )
                    policy_data = result.fetchall()
                    
                    if policy_data:
                        self._policies_cache = [
                            {
                                "type": row[0],
                                "title": row[1],
                                "description": row[2],
                                "rules": row[3]
                            }
                            for row in policy_data
                        ]
                    else:
                        self._policies_cache = []
                    
                    logger.info(f"‚úÖ {len(self._policies_cache)} pol√≠ticas carregadas")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro ao buscar pol√≠ticas: {e}")
                    # Se a tabela n√£o existe, usar dados padr√£o
                    if "does not exist" in str(e):
                        logger.warning("‚ö†Ô∏è  Tabela business_policies n√£o existe, usando dados padr√£o")
                        self._policies_cache = self._get_default_business_policies()
                    else:
                        self._policies_cache = []
        
        return self._policies_cache
    
    def _get_default_payment_methods(self) -> List[Dict]:
        """Retorna formas de pagamento padr√£o quando a tabela n√£o existe"""
        return [
            {"name": "Dinheiro", "description": "Pagamento em esp√©cie", "additional_info": None},
            {"name": "PIX", "description": "Transfer√™ncia instant√¢nea", "additional_info": "Chave PIX dispon√≠vel"},
            {"name": "Cart√£o de D√©bito", "description": "Cart√£o de d√©bito", "additional_info": None},
            {"name": "Cart√£o de Cr√©dito", "description": "Cart√£o de cr√©dito", "additional_info": "Parcelamento dispon√≠vel"}
        ]
    
    def _get_default_business_policies(self) -> List[Dict]:
        """Retorna pol√≠ticas padr√£o quando a tabela n√£o existe"""
        return [
            {
                "type": "cancellation",
                "title": "Pol√≠tica de Cancelamento", 
                "description": "Cancelamentos devem ser feitos com pelo menos 24 horas de anteced√™ncia.",
                "rules": {"min_hours": 24, "refund": False}
            },
            {
                "type": "rescheduling",
                "title": "Pol√≠tica de Reagendamento",
                "description": "Reagendamentos podem ser feitos at√© 2 horas antes do hor√°rio marcado.",
                "rules": {"min_hours": 2, "max_reschedules": 2}
            },
            {
                "type": "no_show", 
                "title": "Pol√≠tica de Falta",
                "description": "Faltas sem aviso pr√©vio resultam em cobran√ßa de taxa.",
                "rules": {"fee_percentage": 50, "grace_period": 15}
            }
        ]

    async def get_complete_business_info(self) -> Dict:
        """
        Busca informa√ß√µes completas do neg√≥cio incluindo novos dados
        
        Returns:
            Dicion√°rio com todas as informa√ß√µes do neg√≥cio
        """
        try:
            # Buscar todos os dados em paralelo
            services = await self.get_active_services()
            company_info = await self.get_company_info()
            business_hours = await self.get_business_hours()
            payment_methods = await self.get_payment_methods()
            policies = await self.get_business_policies()
            
            return {
                "services": services,
                "company_info": company_info,
                "business_hours": business_hours,
                "payment_methods": payment_methods,
                "policies": policies,
                "completeness": {
                    "services": len(services) > 0,
                    "company_info": company_info is not None,
                    "business_hours": business_hours is not None,
                    "payment_methods": len(payment_methods or []) > 0,
                    "policies": len(policies or []) > 0
                }
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar informa√ß√µes completas: {e}")
            return {}
    
    async def get_services_dict(self) -> Dict[str, int]:
        """
        Retorna dicion√°rio de servi√ßos no formato compat√≠vel com o sistema legado
        
        Returns:
            Dict com nome do servi√ßo como chave e dura√ß√£o como valor
        """
        services = await self.get_active_services()
        
        return {
            service.name.lower(): service.duration
            for service in services
        }
    
    async def clear_cache(self):
        """Limpa o cache for√ßando nova busca na database"""
        self._services_cache = None
        self._company_info_cache = None
        logger.info("üîÑ Cache de dados do neg√≥cio limpo")


# Inst√¢ncia global do servi√ßo
business_data_service = BusinessDataService(business_id=1)


async def get_database_services() -> List[ServiceData]:
    """Fun√ß√£o de conveni√™ncia para buscar servi√ßos da database"""
    return await business_data_service.get_active_services()


async def get_database_services_formatted() -> str:
    """Fun√ß√£o de conveni√™ncia para buscar servi√ßos formatados da database"""
    return await business_data_service.get_services_formatted_text()


async def find_database_service(service_name: str) -> Optional[ServiceData]:
    """Fun√ß√£o de conveni√™ncia para buscar um servi√ßo espec√≠fico da database"""
    return await business_data_service.find_service_by_name(service_name)
