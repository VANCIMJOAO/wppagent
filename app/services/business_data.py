"""
Servi√ßo de Dados de Neg√≥cio - Interface com Database
Busca informa√ß√µes reais da database usando asyncpg diretamente
"""

import asyncpg
from typing import List, Dict, Optional
from app.utils.logger import get_logger
import logging

logger = get_logger(__name__)


class ServiceData:
    """Classe simples para representar dados de servi√ßo"""
    def __init__(self, id: int, name: str, price: str, duration: int, description: str = ""):
        self.id = id
        self.name = name
        self.price = price  # Agora √© string (ex: "R$ 50,00")
        self.duration = duration
        self.description = description
    
    def __repr__(self):
        return f"ServiceData(name='{self.name}', price='{self.price}', duration={self.duration})"


class BusinessDataService:
    """Servi√ßo para buscar dados reais do neg√≥cio da database usando asyncpg"""
    
    def __init__(self, business_id: int = 3):  # Usar business_id = 3 igual ao dynamic_prompts
        self.business_id = business_id
        # URL ID√äNTICA ao comprehensive_bot_test.py
        self.DATABASE_URL = "postgresql://postgres:UGARTPCwAADBBeBLctoRnQXLsoUvLJxz@caboose.proxy.rlwy.net:13910/railway"
        self._services_cache = None
        self._company_info_cache = None
        self._business_hours_cache = None
        self._payment_methods_cache = None
        self._policies_cache = None
    
    async def _get_connection(self):
        """Conecta usando asyncpg diretamente - IGUAL AO COMPREHENSIVE_BOT_TEST"""
        try:
            conn = await asyncpg.connect(self.DATABASE_URL)
            return conn
        except Exception as e:
            logger.error(f"‚ùå Erro ao conectar: {e}")
            raise e
    
    async def get_active_services(self, refresh_cache: bool = False) -> List[ServiceData]:
        """
        Busca servi√ßos ativos da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista de objetos ServiceData com nome, pre√ßo e dura√ß√£o
        """
        if self._services_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar servi√ßos IGUAL ao dynamic_prompts.py
                services = await conn.fetch("""
                    SELECT * FROM services 
                    WHERE business_id = $1 AND is_active = true 
                    ORDER BY name
                """, self.business_id)
                
                self._services_cache = [
                    ServiceData(
                        id=service['id'],
                        name=service['name'],
                        price=service['price'],
                        duration=service['duration_minutes'],
                        description=service['description'] or ""
                    )
                    for service in services
                ]
                
                logger.info(f"‚úÖ Carregados {len(self._services_cache)} servi√ßos da database")
                
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar servi√ßos: {e}")
                self._services_cache = []
            finally:
                if conn:
                    await conn.close()
        
        return self._services_cache or []
    
    async def get_company_info(self, refresh_cache: bool = False) -> Optional[Dict]:
        """
        Busca informa√ß√µes da empresa da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Dicion√°rio com informa√ß√µes da empresa
        """
        if self._company_info_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar informa√ß√µes da empresa IGUAL ao dynamic_prompts.py
                company_info = await conn.fetchrow("""
                    SELECT * FROM company_info WHERE business_id = $1
                """, self.business_id)
                
                if company_info:
                    self._company_info_cache = {
                        "company_name": company_info['company_name'],
                        "slogan": company_info.get('slogan', ''),
                        "about_us": company_info.get('about_us', ''),
                        "street_address": company_info.get('street_address', ''),
                        "city": company_info.get('city', ''),
                        "state": company_info.get('state', ''),
                        "phone": company_info.get('phone', ''),
                        "email": company_info.get('email', ''),
                        "website": company_info.get('website', '')
                    }
                    logger.info("‚úÖ Informa√ß√µes da empresa carregadas")
                else:
                    logger.warning("‚ö†Ô∏è Informa√ß√µes da empresa n√£o encontradas")
                    self._company_info_cache = {}
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar informa√ß√µes da empresa: {e}")
                self._company_info_cache = {}
            finally:
                if conn:
                    await conn.close()
        
        return self._company_info_cache
    
    async def get_services_formatted_text(self, user_message: str = "") -> str:
        """
        Retorna texto formatado com servi√ßos e pre√ßos da database
        CORRE√á√ÉO: Divis√£o autom√°tica por limite WhatsApp + detec√ß√£o de "mais servi√ßos"
        
        Args:
            user_message: Mensagem do usu√°rio para detectar se quer parte 2
            
        Returns:
            String formatada com lista de servi√ßos (primeira ou segunda parte)
        """
        services = await self.get_active_services()
        
        if not services:
            return "üîç No momento n√£o temos servi√ßos cadastrados.\nüìû Entre em contato conosco!"
        
        # üî• DETEC√á√ÉO INTELIGENTE: Se usu√°rio pediu "mais servi√ßos", mostrar parte 2
        if "mais servi√ßos" in user_message.lower() or "restante" in user_message.lower():
            return await self.get_services_formatted_text_part2()
        
        # Dividir servi√ßos em duas partes para respeitar limite de 4096 chars
        total_services = len(services)
        mid_point = total_services // 2
        
        text = f"üìã *Nossos Servi√ßos e Pre√ßos (Parte 1/2):*\n\n"
        
        for i, service in enumerate(services[:mid_point], 1):
            text += f"{i}. *{service.name}*\n"
            text += f"   üí∞ {service.price}"
            if service.duration:
                text += f" ‚Ä¢ ‚è∞ {service.duration}min"
            text += "\n"
            if service.description:
                text += f"   ‚ÑπÔ∏è _{service.description}_\n"
            text += "\n"
        
        text += "\nüí¨ *Digite mais servi√ßos para ver o restante*"
        
        return text
    
    async def get_services_formatted_text_part2(self) -> str:
        """
        Retorna segunda parte dos servi√ßos formatados
        
        Returns:
            String formatada com lista de servi√ßos (segunda parte)
        """
        services = await self.get_active_services()
        
        if not services:
            return "üîç N√£o h√° mais servi√ßos para mostrar."
        
        total_services = len(services)
        mid_point = total_services // 2
        
        text = f"üìã *Nossos Servi√ßos e Pre√ßos (Parte 2/2):*\n\n"
        
        for i, service in enumerate(services[mid_point:], mid_point + 1):
            text += f"{i}. *{service.name}*\n"
            text += f"   üí∞ {service.price}"
            if service.duration:
                text += f" ‚Ä¢ ‚è∞ {service.duration}min"
            text += "\n"
            if service.description:
                text += f"   ‚ÑπÔ∏è _{service.description}_\n"
            text += "\n"
        
        text += "\n‚úÖ *Estes s√£o todos os nossos servi√ßos!*\n"
        text += "üìû *Para agendar, me informe:*\n"
        text += "‚Ä¢ Qual servi√ßo deseja\n"
        text += "‚Ä¢ Data e hor√°rio preferido\n"
        text += "‚Ä¢ Seu nome completo"
        
        return text
    
    async def get_company_info_formatted_text(self) -> str:
        """
        Retorna informa√ß√µes da empresa formatadas para WhatsApp
        
        Returns:
            String formatada com informa√ß√µes da empresa
        """
        company_info = await self.get_company_info()
        
        if not company_info:
            return "üè¢ *Studio Beleza & Bem-Estar*\nüìç Endere√ßo: _Rua das Flores, 123 - Centro, S√£o Paulo, SP_\nüìû Contato: (11) 98765-4321\nüìß Email: _contato@studiobeleza.com_"
        
        text = f"üè¢ *{company_info.get('name', 'Studio Beleza & Bem-Estar')}*\n"
        
        if company_info.get('address'):
            text += f"üìç Endere√ßo: _{company_info['address']}_\n"
        
        if company_info.get('phone'):
            text += f"üìû Contato: {company_info['phone']}\n"
        
        if company_info.get('email'):
            text += f"üìß Email: _{company_info['email']}_\n"
        
        if company_info.get('website'):
            text += f"üåê Site: _{company_info['website']}_\n"
        
        return text.strip()
    
    async def find_service_by_name(self, service_name: str) -> Optional[ServiceData]:
        """
        Busca INTELIGENTE de servi√ßos com sin√¥nimos e palavras-chave flex√≠veis
        CORRE√á√ÉO CR√çTICA: Resolve problemas de "limpeza de pele", "massagem", "radiofrequ√™ncia"
        
        Args:
            service_name: Nome ou termo de busca do servi√ßo
            
        Returns:
            Objeto ServiceData ou None se n√£o encontrado
        """
        services = await self.get_active_services()
        
        if not services:
            logger.warning("‚ùå Nenhum servi√ßo dispon√≠vel para busca")
            return None
            
        service_name_clean = service_name.lower().strip()
        
        # üîç FASE 1: Busca exata primeiro
        for service in services:
            if service.name.lower() == service_name_clean:
                logger.info(f"‚úÖ Encontrado por busca exata: {service.name}")
                return service
        
        # üîç FASE 2: Busca parcial (palavra contida no nome)
        for service in services:
            if service_name_clean in service.name.lower():
                logger.info(f"‚úÖ Encontrado por busca parcial: {service.name}")
                return service
        
        # üîç FASE 3: Busca por palavras individuais
        search_words = service_name_clean.split()
        for service in services:
            service_words = service.name.lower().split()
            # Se pelo menos uma palavra da busca est√° no nome do servi√ßo
            if any(word in service.name.lower() for word in search_words):
                logger.info(f"‚úÖ Encontrado por palavra-chave: {service.name} (busca: {search_words})")
                return service
        
        # üîç FASE 4: Mapeamento INTELIGENTE de sin√¥nimos e varia√ß√µes
        # ‚ö†Ô∏è CORRE√á√ÉO CR√çTICA: Mapear todos os termos problem√°ticos identificados
        keywords_map = {
            # PROBLEMAS CR√çTICOS IDENTIFICADOS:
            'limpeza de pele profunda': [
                'limpeza', 'limpeza de pele', 'facial', 'limpeza facial', 
                'limpeza profunda', 'pele', 'tratamento facial'
            ],
            'massagem relaxante': [
                'massagem', 'massagem relaxante', 'relaxante', 'relax', 
                'massoterapia', 'terapia', 'descontra√ß√£o'
            ],
            'massagem modeladora': [
                'massagem modeladora', 'modeladora', 'modelar', 'redutora',
                'massagem redutora', 'corporal'
            ],
            'radiofrequ√™ncia': [
                'radiofrequ√™ncia', 'radiofrequencia', 'radio', 'rf', 
                'radio frequ√™ncia', 'radio-frequ√™ncia'
            ],
            'hidrofacial diamante': [
                'hidrofacial', 'hidro', 'facial diamante', 'diamante',
                'microdermoabras√£o', 'peeling', 'hidrata√ß√£o facial'
            ],
            'criolip√≥lise': [
                'criolip√≥lise', 'criolipolise', 'cryo', 'congelamento', 
                'gordura localizada', 'redu√ß√£o de medidas'
            ],
            'drenagem linf√°tica': [
                'drenagem', 'linf√°tica', 'drenagem linf√°tica', 'drenar',
                'incha√ßo', 'reten√ß√£o', 'detox'
            ],
            'corte feminino': [
                'corte', 'corte feminino', 'cabelo', 'cortar cabelo',
                'corte de cabelo', 'feminino', 'mulher'
            ],
            'escova progressiva': [
                'escova', 'progressiva', 'alisamento', 'alisar',
                'cabelo liso', 'tratamento capilar'
            ],
            'manicure completa': [
                'manicure', 'manicure completa', 'unha', 'unhas',
                'fazer unha', 'cuidar das unhas'
            ],
            'pedicure spa': [
                'pedicure', 'pedi', 'spa', 'p√©s', 'unha do p√©',
                'cuidar dos p√©s', 'pedicure spa'
            ],
            'peeling qu√≠mico': [
                'peeling', 'qu√≠mico', 'peeling qu√≠mico', '√°cido',
                'renova√ß√£o', 'esfolia√ß√£o'
            ],
            'depila√ß√£o pernas completas': [
                'depila√ß√£o', 'pernas', 'perna', 'depilar',
                'pelos', 'cera', 'laser'
            ],
            'depila√ß√£o virilha completa': [
                'virilha', '√≠ntima', 'bikini', 'regi√£o √≠ntima',
                'depila√ß√£o √≠ntima', 'brazilian'
            ],
            'pacote noiva': [
                'noiva', 'casamento', 'pacote', 'dia especial',
                'combo noiva', 'prepara√ß√£o'
            ],
            'day spa relax': [
                'day spa', 'spa', 'relax', 'relaxamento',
                'dia de spa', 'bem-estar', 'autocuidado'
            ]
        }
        
        # Buscar por sin√¥nimos para cada servi√ßo dispon√≠vel
        for service in services:
            service_key = service.name.lower()
            
            # Verificar se existe mapeamento para este servi√ßo
            service_keywords = keywords_map.get(service_key, [])
            
            # Tamb√©m adicionar palavras do pr√≥prio nome como keywords
            service_name_words = service.name.lower().split()
            all_keywords = service_keywords + service_name_words
            
            # Verificar se qualquer palavra da busca corresponde √†s keywords
            if any(keyword in service_name_clean for keyword in all_keywords):
                logger.info(f"‚úÖ Encontrado por sin√¥nimo: {service.name} (termo: '{service_name_clean}')")
                return service
            
            # Verificar tamb√©m se qualquer keyword corresponde a palavras da busca
            search_words = service_name_clean.split()
            if any(search_word in keyword for keyword in all_keywords for search_word in search_words):
                logger.info(f"‚úÖ Encontrado por keyword reversa: {service.name} (busca: {search_words})")
                return service
        
        # üîç FASE 5: Busca SUPER flex√≠vel - qualquer palavra em comum
        for service in services:
            service_words = set(service.name.lower().replace('-', ' ').replace('_', ' ').split())
            search_words = set(service_name_clean.replace('-', ' ').replace('_', ' ').split())
            
            # Se h√° interse√ß√£o entre as palavras
            common_words = service_words.intersection(search_words)
            if common_words:
                logger.info(f"‚úÖ Encontrado por interse√ß√£o: {service.name} (palavras comuns: {common_words})")
                return service
        
        logger.warning(f"‚ùå Servi√ßo n√£o encontrado: '{service_name}' (testados {len(services)} servi√ßos)")
        return None
    
    async def find_services_by_keyword(self, keyword: str, limit: int = 5) -> List[ServiceData]:
        """
        Busca M√öLTIPLOS servi√ßos por palavra-chave (para sugest√µes)
        
        Args:
            keyword: Palavra-chave para buscar
            limit: N√∫mero m√°ximo de resultados
            
        Returns:
            Lista de ServiceData encontrados
        """
        services = await self.get_active_services()
        found_services = []
        
        if not services:
            return found_services
        
        keyword_clean = keyword.lower().strip()
        
        # Buscar servi√ßos que contenham a palavra-chave
        for service in services:
            if keyword_clean in service.name.lower():
                found_services.append(service)
                if len(found_services) >= limit:
                    break
        
        # Se n√£o encontrou nada, buscar por palavras individuais
        if not found_services:
            keyword_words = keyword_clean.split()
            for service in services:
                if any(word in service.name.lower() for word in keyword_words):
                    found_services.append(service)
                    if len(found_services) >= limit:
                        break
        
        logger.info(f"‚úÖ Encontrados {len(found_services)} servi√ßos para '{keyword}'")
        return found_services
    
    async def get_service_info_formatted(self, service_name: str) -> str:
        """
        Busca um servi√ßo e retorna informa√ß√µes formatadas
        CORRE√á√ÉO CR√çTICA: Para resolver problemas de "n√£o oferecemos"
        
        Args:
            service_name: Nome ou termo de busca do servi√ßo
            
        Returns:
            String formatada com informa√ß√µes do servi√ßo ou mensagem de erro
        """
        service = await self.find_service_by_name(service_name)
        
        if service:
            text = f"‚úÖ *{service.name}*\n"
            text += f"üí∞ Pre√ßo: {service.price}\n"
            
            if service.duration:
                text += f"‚è∞ Dura√ß√£o: {service.duration} minutos\n"
            
            if service.description:
                text += f"‚ÑπÔ∏è _Sobre: {service.description}_\n"
            
            text += "\nüìû *Para agendar, me informe:*\n"
            text += "‚Ä¢ Data e hor√°rio preferido\n"
            text += "‚Ä¢ Seu nome completo\n"
            
            return text
        
        else:
            # Buscar servi√ßos similares como sugest√£o
            similar_services = await self.find_services_by_keyword(service_name, 3)
            
            if similar_services:
                text = f"üîç N√£o encontrei exatamente '{service_name}', mas temos estes servi√ßos similares:\n\n"
                
                for i, similar in enumerate(similar_services, 1):
                    text += f"{i}. *{similar.name}* - {similar.price}\n"
                
                text += "\nüí¨ Qual destes servi√ßos te interessa?"
                return text
            
            else:
                return f"üòî Desculpe, n√£o oferecemos '{service_name}' no momento.\n\nüí¨ Digite *servi√ßos* para ver nossa lista completa!"
    
    async def get_business_hours(self, refresh_cache: bool = False) -> Optional[Dict]:
        """
        Busca hor√°rios de funcionamento da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Dicion√°rio com hor√°rios por dia da semana
        """
        if self._business_hours_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar hor√°rios IGUAL ao dynamic_prompts.py
                business_hours = await conn.fetch("""
                    SELECT * FROM business_hours WHERE business_id = $1
                """, self.business_id)
                
                if business_hours:
                    days_map = {
                        0: 'Domingo', 1: 'Segunda', 2: 'Ter√ßa', 
                        3: 'Quarta', 4: 'Quinta', 5: 'Sexta', 6: 'S√°bado'
                    }
                    
                    hours_dict = {}
                    
                    for hour in business_hours:
                        day_val = hour['day_of_week']
                        day_name = days_map.get(day_val, f"Dia {day_val}")
                        
                        if hour.get('is_open', True):
                            open_time = hour['open_time'].strftime('%H:%M') if hour['open_time'] else '09:00'
                            close_time = hour['close_time'].strftime('%H:%M') if hour['close_time'] else '18:00'
                            hours_dict[day_name] = {
                                "open_time": open_time,
                                "close_time": close_time,
                                "is_open": True
                            }
                        else:
                            hours_dict[day_name] = {"is_open": False}
                    
                    self._business_hours_cache = hours_dict
                    logger.info("‚úÖ Hor√°rios de funcionamento carregados")
                else:
                    # Fallback default
                    self._business_hours_cache = {
                        "Segunda": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Ter√ßa": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Quarta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Quinta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Sexta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "S√°bado": {"open_time": "09:00", "close_time": "16:00", "is_open": True},
                        "Domingo": {"is_open": False}
                    }
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar hor√°rios: {e}")
                # Fallback padr√£o
                self._business_hours_cache = {
                    "Segunda": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Ter√ßa": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Quarta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Quinta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Sexta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "S√°bado": {"open_time": "09:00", "close_time": "16:00", "is_open": True},
                    "Domingo": {"is_open": False}
                }
            finally:
                if conn:
                    await conn.close()
        
        return self._business_hours_cache
    
    def _get_default_business_hours(self) -> Dict:
        """Retorna hor√°rios padr√£o quando a tabela n√£o existe"""
        return {
            "hours_by_day": {
                "Segunda": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Ter√ßa": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Quarta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Quinta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Sexta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "S√°bado": {"is_open": False},
                "Domingo": {"is_open": False}
            },
            "formatted_text": "Segunda a Sexta: 09:00 √†s 18:00\nS√°bado: Fechado\nDomingo: Fechado",
            "summary": "Segunda a Sexta: 9h √†s 18h, Fins de semana: Fechado"
        }
    
    async def get_business_hours_formatted_text(self) -> str:
        """
        Retorna hor√°rios de funcionamento formatados para WhatsApp
        
        Returns:
            String formatada com hor√°rios de funcionamento
        """
        hours_data = await self.get_business_hours()
        
        # Buscar nome da empresa para incluir no template
        company_info = await self.get_company_info()
        company_name = "Studio Beleza & Bem-Estar"  # Default
        if company_info and company_info.get('name'):
            company_name = company_info['name']
        
        if not hours_data:
            return f"üè¢ *{company_name}*\nÔøΩ *Hor√°rio de Funcionamento:*\n- _Segunda a Sexta_: 9h √†s 18h\n- _S√°bado_: 9h √†s 16h\n- _Domingo_: üö´ Fechado"
        
        # Usar o texto formatado do cache se dispon√≠vel
        if "formatted_text" in hours_data and hours_data["formatted_text"]:
            text = f"üè¢ *{company_name}*\nÔøΩ *Hor√°rio de Funcionamento:*\n"
            
            # Quebrar por linhas e reformatar com it√°licos
            lines = hours_data["formatted_text"].split('\n')
            for line in lines:
                if "Fechado" in line:
                    # Extrair o dia da semana e colocar em it√°lico
                    day_part = line.split(':')[0].strip()
                    text += f"- _{day_part}_: üö´ Fechado\n"
                else:
                    # Extrair o dia da semana e hor√°rio, colocar dia em it√°lico
                    if ':' in line:
                        day_part = line.split(':')[0].strip()
                        time_part = ':'.join(line.split(':')[1:]).strip()
                        text += f"- _{day_part}_: {time_part}\n"
                    else:
                        text += f"üïò {line}\n"
            
            return text.strip()
        
        # Fallback para formato padr√£o com nova formata√ß√£o
        return f"üè¢ *{company_name}*\nÔøΩ *Hor√°rio de Funcionamento:*\n- _Segunda a Sexta_: 9h √†s 18h\n- _S√°bado_: 9h √†s 16h\n- _Domingo_: üö´ Fechado"
        
        return self._business_hours_cache
    
    async def get_payment_methods(self, refresh_cache: bool = False) -> Optional[List[Dict]]:
        """
        Busca formas de pagamento da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista com formas de pagamento
        """
        if self._payment_methods_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar formas de pagamento IGUAL ao dynamic_prompts.py
                payment_methods = await conn.fetch("""
                    SELECT * FROM payment_methods WHERE business_id = $1
                """, self.business_id)
                
                if payment_methods:
                    self._payment_methods_cache = [
                        {
                            "name": payment['name'],
                            "description": payment.get('description', ''),
                            "additional_info": payment.get('additional_info', '')
                        }
                        for payment in payment_methods
                    ]
                    logger.info(f"‚úÖ Carregadas {len(self._payment_methods_cache)} formas de pagamento")
                else:
                    # Fallback padr√£o
                    self._payment_methods_cache = [
                        {"name": "Dinheiro", "description": "Pagamento √† vista"},
                        {"name": "PIX", "description": "Transfer√™ncia instant√¢nea"},
                        {"name": "Cart√£o de D√©bito", "description": "Pagamento no d√©bito"},
                        {"name": "Cart√£o de Cr√©dito", "description": "Pagamento no cr√©dito"}
                    ]
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar formas de pagamento: {e}")
                # Fallback padr√£o
                self._payment_methods_cache = [
                    {"name": "Dinheiro", "description": "Pagamento √† vista"},
                    {"name": "PIX", "description": "Transfer√™ncia instant√¢nea"},
                    {"name": "Cart√£o de D√©bito", "description": "Pagamento no d√©bito"},
                    {"name": "Cart√£o de Cr√©dito", "description": "Pagamento no cr√©dito"}
                ]
            finally:
                if conn:
                    await conn.close()
        
        return self._payment_methods_cache
    
    async def get_business_policies(self, refresh_cache: bool = False) -> Optional[List[Dict]]:
        """
        Busca pol√≠ticas do neg√≥cio da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista com pol√≠ticas do neg√≥cio
        """
        if self._policies_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar pol√≠ticas IGUAL ao dynamic_prompts.py
                policies = await conn.fetch("""
                    SELECT * FROM business_policies WHERE business_id = $1
                """, self.business_id)
                
                if policies:
                    self._policies_cache = [
                        {
                            "policy_type": policy['policy_type'],
                            "title": policy.get('title', ''),
                            "description": policy.get('description', ''),
                            "rules": policy.get('rules', '')
                        }
                        for policy in policies
                    ]
                    logger.info(f"‚úÖ Carregadas {len(self._policies_cache)} pol√≠ticas")
                else:
                    self._policies_cache = []
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar pol√≠ticas: {e}")
                self._policies_cache = []
            finally:
                if conn:
                    await conn.close()
        
        return self._policies_cache
    
    def _get_default_payment_methods(self) -> List[Dict]:
        """Retorna formas de pagamento padr√£o quando a tabela n√£o existe"""
        return [
            {"name": "Dinheiro", "description": "Pagamento em esp√©cie", "additional_info": None},
            {"name": "PIX", "description": "Transfer√™ncia instant√¢nea", "additional_info": "Chave PIX dispon√≠vel"},
            {"name": "Cart√£o de D√©bito", "description": "Cart√£o de d√©bito", "additional_info": None},
            {"name": "Cart√£o de Cr√©dito", "description": "Cart√£o de cr√©dito", "additional_info": "Parcelamento dispon√≠vel"}
        ]
    
    def _get_default_business_policies(self) -> List[Dict]:
        """Retorna pol√≠ticas padr√£o quando a tabela n√£o existe"""
        return [
            {
                "type": "cancellation",
                "title": "Pol√≠tica de Cancelamento", 
                "description": "Cancelamentos devem ser feitos com pelo menos 24 horas de anteced√™ncia.",
                "rules": {"min_hours": 24, "refund": False}
            },
            {
                "type": "rescheduling",
                "title": "Pol√≠tica de Reagendamento",
                "description": "Reagendamentos podem ser feitos at√© 2 horas antes do hor√°rio marcado.",
                "rules": {"min_hours": 2, "max_reschedules": 2}
            },
            {
                "type": "no_show", 
                "title": "Pol√≠tica de Falta",
                "description": "Faltas sem aviso pr√©vio resultam em cobran√ßa de taxa.",
                "rules": {"fee_percentage": 50, "grace_period": 15}
            }
        ]

    async def get_complete_business_info(self) -> Dict:
        """
        Busca informa√ß√µes completas do neg√≥cio incluindo novos dados
        
        Returns:
            Dicion√°rio com todas as informa√ß√µes do neg√≥cio
        """
        try:
            # Buscar todos os dados em paralelo
            services = await self.get_active_services()
            company_info = await self.get_company_info()
            business_hours = await self.get_business_hours()
            payment_methods = await self.get_payment_methods()
            policies = await self.get_business_policies()
            
            return {
                "services": services,
                "company_info": company_info,
                "business_hours": business_hours,
                "payment_methods": payment_methods,
                "policies": policies,
                "completeness": {
                    "services": len(services) > 0,
                    "company_info": company_info is not None,
                    "business_hours": business_hours is not None,
                    "payment_methods": len(payment_methods or []) > 0,
                    "policies": len(policies or []) > 0
                }
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar informa√ß√µes completas: {e}")
            return {}
    
    async def get_services_dict(self) -> Dict[str, int]:
        """
        Retorna dicion√°rio de servi√ßos no formato compat√≠vel com o sistema legado
        
        Returns:
            Dict com nome do servi√ßo como chave e dura√ß√£o como valor
        """
        services = await self.get_active_services()
        
        return {
            service.name.lower(): service.duration
            for service in services
        }
    
    async def clear_cache(self):
        """Limpa o cache for√ßando nova busca na database"""
        self._services_cache = None
        self._company_info_cache = None
        logger.info("üîÑ Cache de dados do neg√≥cio limpo")


# Inst√¢ncia global do servi√ßo
business_data_service = BusinessDataService()

async def get_database_services_formatted(user_message: str = "") -> str:
    """
    Fun√ß√£o helper para obter servi√ßos formatados da database
    CORRE√á√ÉO: Adiciona fun√ß√£o de busca inteligente
    
    Args:
        user_message: Mensagem do usu√°rio para contexto
        
    Returns:
        String formatada com servi√ßos
    """
    return await business_data_service.get_services_formatted_text(user_message)


async def find_service_smart(service_name: str) -> Optional[ServiceData]:
    """
    Fun√ß√£o helper para busca inteligente de servi√ßos
    NOVA: Para resolver problemas de "n√£o oferecemos"
    
    Args:
        service_name: Nome ou termo de busca
        
    Returns:
        ServiceData encontrado ou None
    """
    return await business_data_service.find_service_by_name(service_name)


async def get_service_info_smart(service_name: str) -> str:
    """
    Fun√ß√£o helper para obter informa√ß√µes formatadas de um servi√ßo
    NOVA: Para substituir respostas de "n√£o oferecemos"
    
    Args:
        service_name: Nome ou termo de busca
        
    Returns:
        String formatada com info do servi√ßo
    """
    return await business_data_service.get_service_info_formatted(service_name)


async def get_database_services() -> List[ServiceData]:
    """Fun√ß√£o de conveni√™ncia para buscar servi√ßos da database"""
    return await business_data_service.get_active_services()


async def get_database_services_formatted(user_message: str = "") -> str:
    """Fun√ß√£o de conveni√™ncia para buscar servi√ßos formatados da database"""
    return await business_data_service.get_services_formatted_text(user_message)


async def find_database_service(service_name: str) -> Optional[ServiceData]:
    """Fun√ß√£o de conveni√™ncia para buscar um servi√ßo espec√≠fico da database"""
    return await business_data_service.find_service_by_name(service_name)
