"""
Servi√ßo de Dados de Neg√≥cio - Interface com Database
Busca informa√ß√µes reais da database usando asyncpg diretamente
"""

import asyncpg
from typing import List, Dict, Optional
from app.utils.logger import get_logger
import logging

logger = get_logger(__name__)


class ServiceData:
    """Classe simples para representar dados de servi√ßo"""
    def __init__(self, id: int, name: str, price: str, duration: int, description: str = ""):
        self.id = id
        self.name = name
        self.price = price  # Agora √© string (ex: "R$ 50,00")
        self.duration = duration
        self.description = description
    
    def __repr__(self):
        return f"ServiceData(name='{self.name}', price='{self.price}', duration={self.duration})"


class BusinessDataService:
    """Servi√ßo para buscar dados reais do neg√≥cio da database usando asyncpg"""
    
    def __init__(self, business_id: int = 3):  # Usar business_id = 3 igual ao dynamic_prompts
        self.business_id = business_id
        # URL ID√äNTICA ao comprehensive_bot_test.py
        self.DATABASE_URL = "postgresql://postgres:UGARTPCwAADBBeBLctoRnQXLsoUvLJxz@caboose.proxy.rlwy.net:13910/railway"
        self._services_cache = None
        self._company_info_cache = None
        self._business_hours_cache = None
        self._payment_methods_cache = None
        self._policies_cache = None
    
    async def _get_connection(self):
        """Conecta usando asyncpg diretamente - IGUAL AO COMPREHENSIVE_BOT_TEST"""
        try:
            conn = await asyncpg.connect(self.DATABASE_URL)
            return conn
        except Exception as e:
            logger.error(f"‚ùå Erro ao conectar: {e}")
            raise e
    
    async def get_active_services(self, refresh_cache: bool = False) -> List[ServiceData]:
        """
        Busca servi√ßos ativos da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista de objetos ServiceData com nome, pre√ßo e dura√ß√£o
        """
        if self._services_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar servi√ßos IGUAL ao dynamic_prompts.py
                services = await conn.fetch("""
                    SELECT * FROM services 
                    WHERE business_id = $1 AND is_active = true 
                    ORDER BY name
                """, self.business_id)
                
                self._services_cache = [
                    ServiceData(
                        id=service['id'],
                        name=service['name'],
                        price=service['price'],
                        duration=service['duration_minutes'],
                        description=service['description'] or ""
                    )
                    for service in services
                ]
                
                logger.info(f"‚úÖ Carregados {len(self._services_cache)} servi√ßos da database")
                
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar servi√ßos: {e}")
                self._services_cache = []
            finally:
                if conn:
                    await conn.close()
        
        return self._services_cache or []
    
    async def get_company_info(self, refresh_cache: bool = False) -> Optional[Dict]:
        """
        Busca informa√ß√µes da empresa da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Dicion√°rio com informa√ß√µes da empresa
        """
        if self._company_info_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar informa√ß√µes da empresa IGUAL ao dynamic_prompts.py
                company_info = await conn.fetchrow("""
                    SELECT * FROM company_info WHERE business_id = $1
                """, self.business_id)
                
                if company_info:
                    self._company_info_cache = {
                        "company_name": company_info['company_name'],
                        "slogan": company_info.get('slogan', ''),
                        "about_us": company_info.get('about_us', ''),
                        "street_address": company_info.get('street_address', ''),
                        "city": company_info.get('city', ''),
                        "state": company_info.get('state', ''),
                        "phone": company_info.get('phone', ''),
                        "email": company_info.get('email', ''),
                        "website": company_info.get('website', '')
                    }
                    logger.info("‚úÖ Informa√ß√µes da empresa carregadas")
                else:
                    logger.warning("‚ö†Ô∏è Informa√ß√µes da empresa n√£o encontradas")
                    self._company_info_cache = {}
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar informa√ß√µes da empresa: {e}")
                self._company_info_cache = {}
            finally:
                if conn:
                    await conn.close()
        
        return self._company_info_cache
    
    async def get_services_formatted_text(self, user_message: str = "") -> str:
        """
        Retorna texto formatado com servi√ßos e pre√ßos da database
        CORRE√á√ÉO: Divis√£o autom√°tica por limite WhatsApp + detec√ß√£o de "mais servi√ßos"
        
        Args:
            user_message: Mensagem do usu√°rio para detectar se quer parte 2
            
        Returns:
            String formatada com lista de servi√ßos (primeira ou segunda parte)
        """
        services = await self.get_active_services()
        
        if not services:
            return "üîç No momento n√£o temos servi√ßos cadastrados.\nüìû Entre em contato conosco!"
        
        # üî• DETEC√á√ÉO INTELIGENTE: Se usu√°rio pediu "mais servi√ßos", mostrar parte 2
        if "mais servi√ßos" in user_message.lower() or "restante" in user_message.lower():
            return await self.get_services_formatted_text_part2()
        
        # Dividir servi√ßos em duas partes para respeitar limite de 4096 chars
        total_services = len(services)
        mid_point = total_services // 2
        
        text = f"üìã *Nossos Servi√ßos e Pre√ßos (Parte 1/2):*\n\n"
        
        for i, service in enumerate(services[:mid_point], 1):
            text += f"{i}. *{service.name}*\n"
            text += f"   üí∞ {service.price}"
            if service.duration:
                text += f" ‚Ä¢ ‚è∞ {service.duration}min"
            text += "\n"
            if service.description:
                text += f"   ‚ÑπÔ∏è _{service.description}_\n"
            text += "\n"
        
        text += "\nüí¨ *Digite mais servi√ßos para ver o restante*"
        
        return text
    
    async def get_services_formatted_text_part2(self) -> str:
        """
        Retorna segunda parte dos servi√ßos formatados
        
        Returns:
            String formatada com lista de servi√ßos (segunda parte)
        """
        services = await self.get_active_services()
        
        if not services:
            return "üîç N√£o h√° mais servi√ßos para mostrar."
        
        total_services = len(services)
        mid_point = total_services // 2
        
        text = f"üìã *Nossos Servi√ßos e Pre√ßos (Parte 2/2):*\n\n"
        
        for i, service in enumerate(services[mid_point:], mid_point + 1):
            text += f"{i}. *{service.name}*\n"
            text += f"   üí∞ {service.price}"
            if service.duration:
                text += f" ‚Ä¢ ‚è∞ {service.duration}min"
            text += "\n"
            if service.description:
                text += f"   ‚ÑπÔ∏è _{service.description}_\n"
            text += "\n"
        
        text += "\n‚úÖ *Estes s√£o todos os nossos servi√ßos!*\n"
        text += "üìû *Para agendar, me informe:*\n"
        text += "‚Ä¢ Qual servi√ßo deseja\n"
        text += "‚Ä¢ Data e hor√°rio preferido\n"
        text += "‚Ä¢ Seu nome completo"
        
        return text
    
    async def get_company_info_formatted_text(self) -> str:
        """
        Retorna informa√ß√µes da empresa formatadas para WhatsApp
        
        Returns:
            String formatada com informa√ß√µes da empresa
        """
        company_info = await self.get_company_info()
        
        if not company_info:
            return "üè¢ *Studio Beleza & Bem-Estar*\nüìç Endere√ßo: _Rua das Flores, 123 - Centro, S√£o Paulo, SP_\nüìû Contato: (11) 98765-4321\nüìß Email: _contato@studiobeleza.com_"
        
        text = f"üè¢ *{company_info.get('name', 'Studio Beleza & Bem-Estar')}*\n"
        
        if company_info.get('address'):
            text += f"üìç Endere√ßo: _{company_info['address']}_\n"
        
        if company_info.get('phone'):
            text += f"üìû Contato: {company_info['phone']}\n"
        
        if company_info.get('email'):
            text += f"üìß Email: _{company_info['email']}_\n"
        
        if company_info.get('website'):
            text += f"üåê Site: _{company_info['website']}_\n"
        
        return text.strip()
    
    async def find_service_by_name(self, service_name: str) -> Optional[ServiceData]:
        """
        Busca um servi√ßo espec√≠fico pelo nome
        
        Args:
            service_name: Nome do servi√ßo para buscar
            
        Returns:
            Objeto ServiceData ou None se n√£o encontrado
        """
        services = await self.get_active_services()
        
        service_name_lower = service_name.lower()
        
        # Busca exata primeiro
        for service in services:
            if service.name.lower() == service_name_lower:
                return service
        
        # Busca parcial
        for service in services:
            if service_name_lower in service.name.lower():
                return service
        
        # Busca por palavras-chave
        keywords_map = {
            'corte masculino': ['corte', 'masculino', 'homem', 'cabelo masculino'],
            'corte feminino': ['corte', 'feminino', 'mulher', 'cabelo feminino'],
            'barba': ['barba', 'fazer barba', 'aparar barba'],
            'manicure': ['manicure', 'unha', 'fazer unha']
        }
        
        for service in services:
            service_keywords = keywords_map.get(service.name.lower(), [])
            if any(keyword in service_name_lower for keyword in service_keywords):
                return service
        
        return None
    
    async def get_business_hours(self, refresh_cache: bool = False) -> Optional[Dict]:
        """
        Busca hor√°rios de funcionamento da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Dicion√°rio com hor√°rios por dia da semana
        """
        if self._business_hours_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar hor√°rios IGUAL ao dynamic_prompts.py
                business_hours = await conn.fetch("""
                    SELECT * FROM business_hours WHERE business_id = $1
                """, self.business_id)
                
                if business_hours:
                    days_map = {
                        0: 'Domingo', 1: 'Segunda', 2: 'Ter√ßa', 
                        3: 'Quarta', 4: 'Quinta', 5: 'Sexta', 6: 'S√°bado'
                    }
                    
                    hours_dict = {}
                    
                    for hour in business_hours:
                        day_val = hour['day_of_week']
                        day_name = days_map.get(day_val, f"Dia {day_val}")
                        
                        if hour.get('is_open', True):
                            open_time = hour['open_time'].strftime('%H:%M') if hour['open_time'] else '09:00'
                            close_time = hour['close_time'].strftime('%H:%M') if hour['close_time'] else '18:00'
                            hours_dict[day_name] = {
                                "open_time": open_time,
                                "close_time": close_time,
                                "is_open": True
                            }
                        else:
                            hours_dict[day_name] = {"is_open": False}
                    
                    self._business_hours_cache = hours_dict
                    logger.info("‚úÖ Hor√°rios de funcionamento carregados")
                else:
                    # Fallback default
                    self._business_hours_cache = {
                        "Segunda": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Ter√ßa": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Quarta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Quinta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "Sexta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                        "S√°bado": {"open_time": "09:00", "close_time": "16:00", "is_open": True},
                        "Domingo": {"is_open": False}
                    }
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar hor√°rios: {e}")
                # Fallback padr√£o
                self._business_hours_cache = {
                    "Segunda": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Ter√ßa": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Quarta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Quinta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "Sexta": {"open_time": "09:00", "close_time": "18:00", "is_open": True},
                    "S√°bado": {"open_time": "09:00", "close_time": "16:00", "is_open": True},
                    "Domingo": {"is_open": False}
                }
            finally:
                if conn:
                    await conn.close()
        
        return self._business_hours_cache
    
    def _get_default_business_hours(self) -> Dict:
        """Retorna hor√°rios padr√£o quando a tabela n√£o existe"""
        return {
            "hours_by_day": {
                "Segunda": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Ter√ßa": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Quarta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Quinta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "Sexta": {"open": "09:00:00", "close": "18:00:00", "is_open": True},
                "S√°bado": {"is_open": False},
                "Domingo": {"is_open": False}
            },
            "formatted_text": "Segunda a Sexta: 09:00 √†s 18:00\nS√°bado: Fechado\nDomingo: Fechado",
            "summary": "Segunda a Sexta: 9h √†s 18h, Fins de semana: Fechado"
        }
    
    async def get_business_hours_formatted_text(self) -> str:
        """
        Retorna hor√°rios de funcionamento formatados para WhatsApp
        
        Returns:
            String formatada com hor√°rios de funcionamento
        """
        hours_data = await self.get_business_hours()
        
        # Buscar nome da empresa para incluir no template
        company_info = await self.get_company_info()
        company_name = "Studio Beleza & Bem-Estar"  # Default
        if company_info and company_info.get('name'):
            company_name = company_info['name']
        
        if not hours_data:
            return f"üè¢ *{company_name}*\nÔøΩ *Hor√°rio de Funcionamento:*\n- _Segunda a Sexta_: 9h √†s 18h\n- _S√°bado_: 9h √†s 16h\n- _Domingo_: üö´ Fechado"
        
        # Usar o texto formatado do cache se dispon√≠vel
        if "formatted_text" in hours_data and hours_data["formatted_text"]:
            text = f"üè¢ *{company_name}*\nÔøΩ *Hor√°rio de Funcionamento:*\n"
            
            # Quebrar por linhas e reformatar com it√°licos
            lines = hours_data["formatted_text"].split('\n')
            for line in lines:
                if "Fechado" in line:
                    # Extrair o dia da semana e colocar em it√°lico
                    day_part = line.split(':')[0].strip()
                    text += f"- _{day_part}_: üö´ Fechado\n"
                else:
                    # Extrair o dia da semana e hor√°rio, colocar dia em it√°lico
                    if ':' in line:
                        day_part = line.split(':')[0].strip()
                        time_part = ':'.join(line.split(':')[1:]).strip()
                        text += f"- _{day_part}_: {time_part}\n"
                    else:
                        text += f"üïò {line}\n"
            
            return text.strip()
        
        # Fallback para formato padr√£o com nova formata√ß√£o
        return f"üè¢ *{company_name}*\nÔøΩ *Hor√°rio de Funcionamento:*\n- _Segunda a Sexta_: 9h √†s 18h\n- _S√°bado_: 9h √†s 16h\n- _Domingo_: üö´ Fechado"
        
        return self._business_hours_cache
    
    async def get_payment_methods(self, refresh_cache: bool = False) -> Optional[List[Dict]]:
        """
        Busca formas de pagamento da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista com formas de pagamento
        """
        if self._payment_methods_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar formas de pagamento IGUAL ao dynamic_prompts.py
                payment_methods = await conn.fetch("""
                    SELECT * FROM payment_methods WHERE business_id = $1
                """, self.business_id)
                
                if payment_methods:
                    self._payment_methods_cache = [
                        {
                            "name": payment['name'],
                            "description": payment.get('description', ''),
                            "additional_info": payment.get('additional_info', '')
                        }
                        for payment in payment_methods
                    ]
                    logger.info(f"‚úÖ Carregadas {len(self._payment_methods_cache)} formas de pagamento")
                else:
                    # Fallback padr√£o
                    self._payment_methods_cache = [
                        {"name": "Dinheiro", "description": "Pagamento √† vista"},
                        {"name": "PIX", "description": "Transfer√™ncia instant√¢nea"},
                        {"name": "Cart√£o de D√©bito", "description": "Pagamento no d√©bito"},
                        {"name": "Cart√£o de Cr√©dito", "description": "Pagamento no cr√©dito"}
                    ]
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar formas de pagamento: {e}")
                # Fallback padr√£o
                self._payment_methods_cache = [
                    {"name": "Dinheiro", "description": "Pagamento √† vista"},
                    {"name": "PIX", "description": "Transfer√™ncia instant√¢nea"},
                    {"name": "Cart√£o de D√©bito", "description": "Pagamento no d√©bito"},
                    {"name": "Cart√£o de Cr√©dito", "description": "Pagamento no cr√©dito"}
                ]
            finally:
                if conn:
                    await conn.close()
        
        return self._payment_methods_cache
    
    async def get_business_policies(self, refresh_cache: bool = False) -> Optional[List[Dict]]:
        """
        Busca pol√≠ticas do neg√≥cio da database usando asyncpg
        
        Args:
            refresh_cache: Se deve atualizar o cache
            
        Returns:
            Lista com pol√≠ticas do neg√≥cio
        """
        if self._policies_cache is None or refresh_cache:
            conn = None
            try:
                conn = await self._get_connection()
                
                # Buscar pol√≠ticas IGUAL ao dynamic_prompts.py
                policies = await conn.fetch("""
                    SELECT * FROM business_policies WHERE business_id = $1
                """, self.business_id)
                
                if policies:
                    self._policies_cache = [
                        {
                            "policy_type": policy['policy_type'],
                            "title": policy.get('title', ''),
                            "description": policy.get('description', ''),
                            "rules": policy.get('rules', '')
                        }
                        for policy in policies
                    ]
                    logger.info(f"‚úÖ Carregadas {len(self._policies_cache)} pol√≠ticas")
                else:
                    self._policies_cache = []
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao buscar pol√≠ticas: {e}")
                self._policies_cache = []
            finally:
                if conn:
                    await conn.close()
        
        return self._policies_cache
    
    def _get_default_payment_methods(self) -> List[Dict]:
        """Retorna formas de pagamento padr√£o quando a tabela n√£o existe"""
        return [
            {"name": "Dinheiro", "description": "Pagamento em esp√©cie", "additional_info": None},
            {"name": "PIX", "description": "Transfer√™ncia instant√¢nea", "additional_info": "Chave PIX dispon√≠vel"},
            {"name": "Cart√£o de D√©bito", "description": "Cart√£o de d√©bito", "additional_info": None},
            {"name": "Cart√£o de Cr√©dito", "description": "Cart√£o de cr√©dito", "additional_info": "Parcelamento dispon√≠vel"}
        ]
    
    def _get_default_business_policies(self) -> List[Dict]:
        """Retorna pol√≠ticas padr√£o quando a tabela n√£o existe"""
        return [
            {
                "type": "cancellation",
                "title": "Pol√≠tica de Cancelamento", 
                "description": "Cancelamentos devem ser feitos com pelo menos 24 horas de anteced√™ncia.",
                "rules": {"min_hours": 24, "refund": False}
            },
            {
                "type": "rescheduling",
                "title": "Pol√≠tica de Reagendamento",
                "description": "Reagendamentos podem ser feitos at√© 2 horas antes do hor√°rio marcado.",
                "rules": {"min_hours": 2, "max_reschedules": 2}
            },
            {
                "type": "no_show", 
                "title": "Pol√≠tica de Falta",
                "description": "Faltas sem aviso pr√©vio resultam em cobran√ßa de taxa.",
                "rules": {"fee_percentage": 50, "grace_period": 15}
            }
        ]

    async def get_complete_business_info(self) -> Dict:
        """
        Busca informa√ß√µes completas do neg√≥cio incluindo novos dados
        
        Returns:
            Dicion√°rio com todas as informa√ß√µes do neg√≥cio
        """
        try:
            # Buscar todos os dados em paralelo
            services = await self.get_active_services()
            company_info = await self.get_company_info()
            business_hours = await self.get_business_hours()
            payment_methods = await self.get_payment_methods()
            policies = await self.get_business_policies()
            
            return {
                "services": services,
                "company_info": company_info,
                "business_hours": business_hours,
                "payment_methods": payment_methods,
                "policies": policies,
                "completeness": {
                    "services": len(services) > 0,
                    "company_info": company_info is not None,
                    "business_hours": business_hours is not None,
                    "payment_methods": len(payment_methods or []) > 0,
                    "policies": len(policies or []) > 0
                }
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar informa√ß√µes completas: {e}")
            return {}
    
    async def get_services_dict(self) -> Dict[str, int]:
        """
        Retorna dicion√°rio de servi√ßos no formato compat√≠vel com o sistema legado
        
        Returns:
            Dict com nome do servi√ßo como chave e dura√ß√£o como valor
        """
        services = await self.get_active_services()
        
        return {
            service.name.lower(): service.duration
            for service in services
        }
    
    async def clear_cache(self):
        """Limpa o cache for√ßando nova busca na database"""
        self._services_cache = None
        self._company_info_cache = None
        logger.info("üîÑ Cache de dados do neg√≥cio limpo")


# Inst√¢ncia global do servi√ßo
business_data_service = BusinessDataService(business_id=3)


async def get_database_services() -> List[ServiceData]:
    """Fun√ß√£o de conveni√™ncia para buscar servi√ßos da database"""
    return await business_data_service.get_active_services()


async def get_database_services_formatted(user_message: str = "") -> str:
    """Fun√ß√£o de conveni√™ncia para buscar servi√ßos formatados da database"""
    return await business_data_service.get_services_formatted_text(user_message)


async def find_database_service(service_name: str) -> Optional[ServiceData]:
    """Fun√ß√£o de conveni√™ncia para buscar um servi√ßo espec√≠fico da database"""
    return await business_data_service.find_service_by_name(service_name)
