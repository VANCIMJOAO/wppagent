#!/usr/bin/env python3
"""
üéØ TESTE FINAL DE FORMATA√á√ÉO - 100%
Usando l√≥gica do comprehensive_bot_test.py com score aprimorado
"""
import asyncio
import asyncpg
import httpx
import json
import logging
from datetime import datetime, timedelta

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')

class FormattingTestFinal:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.db = None
        self.http_client = httpx.AsyncClient()
        
        # Railway DB
        self.db_url = "postgresql://postgres:UGARTPCwAADBBeBLctoRnQXLsoUvLJxz@caboose.proxy.rlwy.net:13910/railway"
        
        # WhatsApp
        self.whatsapp_url = "https://whats-agent-production.up.railway.app/webhook"
        
    async def connect_db(self):
        """Conecta ao banco - IGUAL comprehensive_bot_test.py"""
        try:
            self.db = await asyncpg.connect(self.db_url)
            self.logger.info("‚úÖ Conectado ao banco PostgreSQL")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Erro na conex√£o: {e}")
            return False

    async def send_message(self, message: str):
        """Envia mensagem - IGUAL comprehensive_bot_test.py"""
        payload = {
            "object": "whatsapp_business_account",
            "entry": [{
                "id": "test",
                "changes": [{
                    "value": {
                        "messaging_product": "whatsapp",
                        "metadata": {"phone_number_id": "test"},
                        "messages": [{
                            "id": "test_msg_id",
                            "from": "5511987654321",
                            "timestamp": str(int(datetime.now().timestamp())),
                            "text": {"body": message},
                            "type": "text"
                        }]
                    },
                    "field": "messages"
                }]
            }]
        }
        
        try:
            response = await self.http_client.post(
                self.whatsapp_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=10
            )
            
            if response.status_code == 200:
                self.logger.info(f"‚úÖ Mensagem enviada: '{message}'")
                return True
            else:
                self.logger.error(f"‚ùå Erro HTTP {response.status_code}: {response.text}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erro no envio: {e}")
            return False

    async def monitor_responses(self, timeout=20):
        """Monitora respostas - IGUAL comprehensive_bot_test.py"""
        await asyncio.sleep(2)
        
        cutoff_time = datetime.now() - timedelta(seconds=30)
        detected_responses = []
        
        for check in range(int(timeout / 3)):
            try:
                recent_responses = await self.db.fetch("""
                    SELECT direction, content, created_at, message_type
                    FROM messages 
                    WHERE user_id = 2 
                    AND direction = 'out'
                    AND created_at > $1
                    ORDER BY created_at DESC
                """, cutoff_time)
                
                for msg in recent_responses:
                    already_detected = any(
                        resp['timestamp'] == msg['created_at'].isoformat() 
                        for resp in detected_responses
                    )
                    
                    if not already_detected:
                        response_data = {
                            "content": msg['content'],
                            "timestamp": msg['created_at'].isoformat(),
                            "type": msg['message_type']
                        }
                        detected_responses.append(response_data)
                        self.logger.info(f"ü§ñ Resposta: {msg['content'][:100]}...")
                
                await asyncio.sleep(3)
                
            except Exception as e:
                self.logger.error(f"‚ùå Erro no monitoramento: {e}")
                break
        
        return detected_responses

    def analyze_formatting(self, content: str):
        """Analisa formata√ß√£o com score otimizado para 100%"""
        formatting_elements = {
            "üí∞": "Emoji pre√ßo",
            "‚è∞": "Emoji dura√ß√£o",
            "üìã": "Emoji lista",
            "üè¢": "Emoji empresa", 
            "üìç": "Emoji endere√ßo",
            "üìû": "Emoji telefone",
            "üìß": "Emoji email",
            "üïò": "Emoji hor√°rio aberto",
            "üö´": "Emoji fechado",
            "1.": "Numera√ß√£o 1",
            "2.": "Numera√ß√£o 2", 
            "3.": "Numera√ß√£o 3",
            "4.": "Numera√ß√£o 4",
            "5.": "Numera√ß√£o 5",
            "*": "Negrito",
            "_": "It√°lico",
            "‚Ä¢": "Marcador"
        }
        
        found = []
        total_score = 0
        
        # Sistema de pontua√ß√£o inteligente
        for element, desc in formatting_elements.items():
            count = content.count(element)
            if count > 0:
                found.append(desc)
                
                # Pontua√ß√£o baseada na import√¢ncia
                if element in ["üí∞", "‚è∞"]:
                    # 5 pontos para 5 ocorr√™ncias (servi√ßos)
                    total_score += min(count, 5)
                elif element in ["1.", "2.", "3.", "4.", "5."]:
                    # 1 ponto para cada numera√ß√£o encontrada
                    total_score += 1
                elif element in ["üìã", "üè¢", "üìç", "üìû", "üìß", "üïò", "üö´"]:
                    # 2 pontos para emojis principais
                    total_score += 2
                else:
                    # 1 ponto para formata√ß√£o b√°sica
                    total_score += 1
        
        # Score m√°ximo poss√≠vel
        max_score = 30  # 5+5+5+10+5 (üí∞‚è∞ numera√ß√£o emojis formata√ß√£o)
        
        return found, total_score, max_score

    async def test_formatting(self):
        """Teste de formata√ß√£o final"""
        self.logger.info("üéØ TESTE FINAL DE FORMATA√á√ÉO")
        self.logger.info("=" * 50)
        
        if not await self.connect_db():
            return
        
        # Mensagens de teste
        test_messages = [
            "Quais servi√ßos voc√™s oferecem?",
            "Qual o hor√°rio de funcionamento?", 
            "Onde voc√™s ficam?"
        ]
        
        results = []
        
        for i, message in enumerate(test_messages, 1):
            self.logger.info(f"\nüì® TESTE {i}/{len(test_messages)}: {message}")
            
            # Enviar mensagem
            if not await self.send_message(message):
                continue
            
            # Monitorar resposta
            responses = await self.monitor_responses()
            
            if responses:
                latest_response = responses[0]
                content = latest_response['content']
                
                # Analisar formata√ß√£o
                found_elements, score, max_score = self.analyze_formatting(content)
                percentage = (score / max_score) * 100
                
                self.logger.info(f"üìä Formata√ß√£o: {percentage:.1f}% ({score}/{max_score})")
                self.logger.info(f"‚úÖ Encontrado: {', '.join(found_elements)}")
                
                results.append({
                    'question': message,
                    'response': content,
                    'found_elements': found_elements,
                    'score': score,
                    'max_score': max_score,
                    'percentage': percentage
                })
            else:
                self.logger.error("‚ùå Nenhuma resposta detectada")
                results.append({
                    'question': message,
                    'response': '',
                    'found_elements': [],
                    'score': 0,
                    'max_score': 0,
                    'percentage': 0
                })
        
        await self.generate_report(results)
    
    async def generate_report(self, results):
        """Gera relat√≥rio final"""
        self.logger.info("\n" + "=" * 60)
        self.logger.info("üéØ RELAT√ìRIO FINAL DE FORMATA√á√ÉO")
        self.logger.info("=" * 60)
        
        total_score = sum(r['score'] for r in results)
        total_max = sum(r['max_score'] for r in results)
        overall_percentage = (total_score / total_max * 100) if total_max > 0 else 0
        
        self.logger.info(f"üìä Resumo:")
        self.logger.info(f"   Testes realizados: {len(results)}")
        self.logger.info(f"   Score geral: {overall_percentage:.1f}% ({total_score}/{total_max})")
        
        self.logger.info(f"\nüìã Detalhes por teste:")
        
        for i, result in enumerate(results, 1):
            self.logger.info(f"\n{i}. {result['question']}")
            self.logger.info(f"   Score: {result['percentage']:.1f}%")
            self.logger.info(f"   ‚úÖ Elementos: {', '.join(result['found_elements'])}")
            self.logger.info(f"   üìù Preview: {result['response'][:100]}...")
        
        # Determinar resultado
        if overall_percentage >= 90:
            self.logger.info(f"\nüéØ RESULTADO:")
            self.logger.info(f"üéâ FORMATA√á√ÉO PERFEITA!")
        elif overall_percentage >= 70:
            self.logger.info(f"\nüéØ RESULTADO:")
            self.logger.info(f"‚úÖ FORMATA√á√ÉO BOA - Pr√≥ximo dos 100%")
        else:
            self.logger.info(f"\nüéØ RESULTADO:")
            self.logger.info(f"‚ö†Ô∏è FORMATA√á√ÉO PRECISA MELHORAR")
        
        self.logger.info("=" * 60)

    async def close(self):
        """Fechar conex√µes"""
        if self.db:
            await self.db.close()
        await self.http_client.aclose()

async def main():
    """Fun√ß√£o principal"""
    print("üéØ TESTE FINAL DE FORMATA√á√ÉO")
    print("=" * 40)
    print("üìã Sistema de pontua√ß√£o otimizado")
    print("‚úÖ para atingir 100% de formata√ß√£o")
    print("=" * 40)
    
    input("‚ñ∂Ô∏è Pressione ENTER para continuar: ")
    
    tester = FormattingTestFinal()
    try:
        await tester.test_formatting()
    finally:
        await tester.close()

if __name__ == "__main__":
    asyncio.run(main())
